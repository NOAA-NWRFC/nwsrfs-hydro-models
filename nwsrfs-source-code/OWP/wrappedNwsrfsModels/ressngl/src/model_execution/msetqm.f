C MODULE MSETQM
C-----------------------------------------------------------------------
C
C
C     DESC - THIS SUBROUTINE PERFORMS THE SETQMEAN MOD
C
      SUBROUTINE MSETQM(IIDATE, LLDATE, NVALS, VALUES, IDT, VM126)
C
!      LOGICAL M126ON
C
      INCLUDE 'flogm'
      INCLUDE 'fctime'
      INCLUDE 'common/mod126'
!      COMMON/MOD126/M126ON,MJ126,NVM126,VM126(124)
C
!      DIMENSION VALUES(124),TEMP1(124)
      DIMENSION VALUES(NVALS),TEMP1(NVALS), VM126(*)
      INTEGER   IDT, ISETMODS
      CHARACTER*3 MODTZC
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/ofs/src/fcst_mods/RCS/msetqm.f,v $
     . $',                                                             '
     .$Id: msetqm.f,v 1.7 1998/07/02 20:50:37 page Exp $
     . $' /
C    ===================================================================
C
C STORE MOD INFO TO LOCAL VARIABLES USE
C
      WRITE(MESSAGESTRING,10) IIDATE, LLDATE
10    FORMAT(1H0,10X,'*** MSETQM MOD ENTERED *** - DATE=',
     1I11,', VALID DATE=',I11) 
      call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)

      IDATE=IIDATE 
      LDATE=LLDATE 
      MODTZC='Z  ' 
      ISETMODS=0
      
C
      ICOMP=((LDACPD-1)*24)+LHRCPD
C
C  CHECK IF DATE IS LESS THAN LASTCOMPDATE OR LSTCMPDY DATE
C  AND LASTCOMPDATE EQUALS LSTCMPDY DATE FOR SETQMEAN MOD
C
      IF(IDATE.LE.LDATE) GOTO 20
      IF(LDATE.EQ.ICOMP) GOTO 20
      GOTO 390
C
C     SEE IF DATE IS WITHIN RUN PERIOD
C
20    ISTHR=(IDA-1)*24+IHZERO
      IENHR=(LDA-1)*24+LHR
C
C     IF(IENHR.GE.IDATE.AND.ISTHR.LE.IDATE)GO TO 40
      IF(IENHR.GE.IDATE) GOTO 40
C
C     START DATE FOR CHANGES AFTER ALLOWABLE WINDOW
C
25    CALL MDYH2(IDA,IHZERO,IM1,ID1,IY1,IH1,DUM1,DUM2,MODTZC)
      CALL MDYH2(LDA,LHR,IM2,ID2,IY2,IH2,DUM1,DUM2,MODTZC)
      IXDA=IDATE/24+1
      IXHR=IDATE-(IXDA-1)*24
      IF(IXHR.EQ.0)IXDA=IXDA-1
      IF(IXHR.EQ.0)IXHR=24
      CALL MDYH2(IXDA,IXHR,IM3,ID3,IY3,IH3,DUM1,DUM2,MODTZC)
C
      WRITE(MESSAGESTRING,30)
     >IM3,ID3,IY3,IH3,MODTZC,IM1,ID1,IY1,IH1,MODTZC,
     >IM2,ID2,IY2,IH2,MODTZC
30    FORMAT(1H0,10X,'**WARNING** THE STARTING DATE FOR CHANGES ',
     1 'ENTERED IN THE ',
     1 'SETQMEAN MOD (',I2,1H/,I2,1H/,I4,1H-,I2,1X,A4,1H)/11X,
     2 'IS NOT WITHIN THE CURRENT RUN PERIOD (',I2,1H/,I2,
     3 1H/,I4,1H-,I2,1X,A4,4H TO ,I2,1H/,I2,1H/,I4,1H-,I2,1X,A4,1H)/
     4 11X,'THESE CHANGES WILL BE IGNORED.')
       call logfromfortran(WARNING_LEVEL, MESSAGESTRING)
      GO TO 390
C   
 40   MXVALS=NVALS !124
      NVPDT=1
C
C     CHECK TO SEE IF ALL VALUES IN VALUES() ARRAY ARE USED OR GET
C     TRUNCATED
C
      IF (IDATE.GT.ISTHR) GOTO 225
C
      NDEL=((ISTHR-IDATE+(IDT/2))/IDT) + 1
      IDATE=ISTHR
      DO 221 III=1,MXVALS
         TEMP1(III)=0.0
221   CONTINUE
      JJ=0
      DO 222 IIII=NDEL+1,NVALS
         TEMP1(JJ+1)=VALUES(IIII)
         JJ=JJ+1
222   CONTINUE
C
      CALL UMEMOV(TEMP1,VALUES,MXVALS)
      NVALS=JJ
C
      if (nvals.gt.0) goto 225

      IF (LDATE.LT.ISTHR) THEN
         IDATE=IIDATE
	 GO TO 25
      END IF
      
      IXDA=IIDATE/24+1
      IXHR=IIDATE-(IXDA-1)*24
      IF(IXHR.EQ.0)IXDA=IXDA-1
      IF(IXHR.EQ.0)IXHR=24
      CALL MDYH2(IXDA,IXHR,IM1,ID1,IY1,IH1,DUM1,DUM2,MODTZC)
C
      CALL MDYH2(IDA,IHZERO,IM2,ID2,IY2,IH2,DUM1,DUM2,MODTZC)
      
      IF (FEWSDEBUG.GE.1) THEN
         WRITE(MESSAGESTRING,444)
     1      IM1,ID1,IY1,IH1,MODTZC,IM2,ID2,IY2,IH2,MODTZC,NDEL
444   FORMAT(1H0,10X,'** WARNING ** IN SETQMEAN MOD - START DATE (',I2,
     1  '/',I2,'/',I4,'-',I2,1X,A4,') IS BEFORE START RUN DATE (',I2,
     2  '/',I2,'/',I4,'-',I2,1X,A4,')'/,25X,'THE FIRST ',I4,' VALUE(S)',
     3  ' BEFORE AND AT START DATE ON THE MOD CARD ARE IGNORED.')
         call logfromfortran(WARNING_LEVEL,MESSAGESTRING)
      END IF
C
225   CONTINUE
C
CP 4/10/09 We don't want truncate value(s) if LSTCMPDY is beyond valid 
CP date 
CP    IF (LDATE.GE.ICOMP) GOTO 229
C
CP    NSLECT=((LDATE-IDATE+(IDT/2))/IDT) + 1
CP    N1=NSLECT
CP    NVALSO=NVALS
CP    IF (NSLECT.GT.NVALS) NSLECT=NVALS
CP    DO 226 LL=1,MXVALS
CP       TEMP1(LL)=0.0
CP6   CONTINUE
CP    KK=0
CP    DO 227 LLL=1,NSLECT
CP       TEMP1(KK+1)=VALUES(LLL)
CP       KK=KK+1
CP7   CONTINUE
C
CP    NVALS=KK
CP    CALL UMEMOV(TEMP1,VALUES,MXVALS)
C     
CP    IF (NVALSO.LE.N1) GOTO 229
c
CP    NDIFF=NVALSO-N1
c
CP    IXDA=ICOMP/24+1
CP    IXHR=ICOMP-(IXDA-1)*24
CP    IF(IXHR.EQ.0)IXDA=IXDA-1
CP    IF(IXHR.EQ.0)IXHR=24
CP    CALL MDYH2(IXDA,IXHR,IM1,ID1,IY1,IH1,DUM1,DUM2,MODTZC)
c
CP    IXDA=LDATE/24+1
CP    IXHR=LDATE-(IXDA-1)*24
CP    IF(IXHR.EQ.0)IXDA=IXDA-1
CP    IF(IXHR.EQ.0)IXHR=24
CP    CALL MDYH2(IXDA,IXHR,IM2,ID2,IY2,IH2,DUM1,DUM2,MODTZC)
C
C
CP    WRITE(MESSAGESTRING,228)
CP   >IM1,ID1,IY1,IH1,MODTZC,IM2,ID2,IY2,IH2,MODTZC,ndiff
CP228   FORMAT(1H0,10X,'** WARNING ** IN SETQMEAN MOD - LSTCMPDY (',I2,
CP   1  '/',I2,'/',I4,'-',I2,1X,A4,') IS BEYOND VALID DATE (',I2,'/',I2,
CP   2  '/',I4,'-',I2,1X,A4,')'/,25X,'THE ',I2,' VALUE(S) AFTER VALID ',
CP   3  'DATE ARE IGNORED.')
CP    call logfromfortran(WARNING_LEVEL,MESSAGESTRING)
c     CALL WARN
CP229 continue
C
C     IF START HOUR NOT ENTERED - USE DEFAULT VALUE OF 12Z
C     IF START HOUR ENTERED - SET TO CLOSEST DT OF TIME SERIES
C
C     IF HOUR ENTERED IIDATE LESS THAN ZERO
C
C
      IF(IIDATE.LT.0) GO TO 230
C
C     HOUR NOT ENTERED - IDATE SHOULD BE DIVISIBLE BY 24
C
      JSTHR=IDATE
      GO TO 240
C
230   CONTINUE
C
C     HOUR ENTERED - SET TO NEAREST DT
C
      JSTHR=MISTDT(IDATE,IDT)
C
240   CONTINUE
C
C     NOW COMPUTE ENDING HOUR FOR TIME SERIES VALUES ENTERED
C
      ISPAN=IDT*(((NVALS-1)/NVPDT)*NVPDT)
      JENHR=JSTHR+ISPAN
C
C     NOW SEE IF ANY OF PERIOD ENTERED IS WITHIN THE CURRENT RUN PERIOD
C
      IF (FEWSDEBUG.GE.3) THEN
        WRITE(MESSAGESTRING,250)ISTHR,IENHR,JSTHR,JENHR,IDA,IHR,
     1  LDA,LHR,IDADAT,IHZERO,IDT,NVALS,NVPDT,ISPAN
250     FORMAT(11X,'CHECKING TIME PERIOD -  ISTHR, IENHR, JSTHR, JENHR'/
     1 33X,4I7/11X,'IDA,  IHR,  LDA,  LHR,  IDADAT,  IHZERO,  IDT'/
     2 8X,4I6,I8,I9,I6/11X,'NVALS, NVPDT, ISPAN'/
     3 11X,I4,I7,I7)
        call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)
      END IF
C
      IF(JSTHR.GT.IENHR.OR.JENHR.LT.ISTHR)GO TO 260
C
C     SOME OF PERIOD BEING CHANGED IS WITHIN THE RUN PERIOD
C
      GO TO 280
C
260   CONTINUE
C
C     NONE OF THE PERIOD BEING CHANGED IS WITHIN THE RUN PERIOD
C
      WRITE(MESSAGESTRING,270) 
270   FORMAT(1H0,10X,'**WARNING** NONE OF THE CHANGES REQUESTED FOR ',
     1 'RES-SNGL OPERATION SETQMEAN',1H ,
     2 'ARE WITHIN THE CURRENT RUN PERIOD.')
      call logfromfortran(WARNING_LEVEL,MESSAGESTRING)
      GO TO 390
C
280   CONTINUE
C
C     CHECK IF VALUE ENTERED IS NEGATIVE VALUE THEN IGNORE MODs
C
      DO I=1, NVALS
        IF (VALUES(I).LT.0.0 .AND. VALUES(I) .NE. -888.) THEN !GO TO 320
           WRITE(MESSAGESTRING,310) I
310   FORMAT(1H0,10X,'** WARNING ** IN SETQMEAN MOD - FOR RES-SNGL ',
     1 'OPERATION SETQMEAN',/11X,'VALUE NUMBER ',I3,' IS LESS THAN ',
     2 'ZERO - NEGATIVE DATA ARE NOT ALLOWED FOR THIS MOD.'/
     3  11X,'NO CHANGES WILL BE MADE TO THIS OPERATION.')
           call logfromfortran(WARNING_LEVEL,MESSAGESTRING)
           GO TO 390
        END IF
      END DO
C
C
C     STORE INFO IN COMMON BLOCK /MOD126/
C
      M126ON=.TRUE.
      MJ126=JSTHR
      NVM126=NVALS
C
C     GET UNITS CONVERSION FACTORS IF NEEDED
C
c     IF (MODARRAY(1).EQ.1)GO TO 350  !in METRIC
C
c     CALL FCONVT(4HCMS ,4HL3/T,EUNITS,XMULT,XADD,IER)
c     XADD=0.0
c     XMULT=35.3150978
C
C     CONVERT CFS TO CMS
C
c     WRITE(MESSAGESTRING,330) NVALS,JSTHR
c30   FORMAT(11X,'STORING ',I4,' VALUES IN VM126 FOR JSTHR =',I11,
c    1 '.  CHANGING UNITS FROM CFS TO CMS.')
c     call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)
c     DO 340 I=1,NVALS
c40   VM126(I)=(VALUES(I)-XADD)/XMULT
C
C     NO CONVERSION NEEDED
C
c50   WRITE(MESSAGESTRING,360) NVALS,JSTHR
c60   FORMAT(11X,'STORING ',I4,' VALUES IN VM126 FOR JSTHR =',I11,
c    1 '.  NO UNITS CONVERSION.')
c     call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)
      DO 370 I=1,NVALS
       IF ( VALUES(I) .EQ. -888. ) ISETMODS = 1
370   VM126(I)=VALUES(I)
c
390   CONTINUE

CP ADD FOR TESTING================
      IXDA=JSTHR/24+1
      IXHR=JSTHR-(IXDA-1)*24
      IF(IXHR.EQ.0)IXDA=IXDA-1
      IF(IXHR.EQ.0)IXHR=24
      CALL MDYH2(IXDA,IXHR,IM1,ID1,IY1,IH1,DUM1,DUM2,MODTZC)
c
      IXDA=JENHR/24+1
      IXHR=JENHR-(IXDA-1)*24
      IF(IXHR.EQ.0)IXDA=IXDA-1
      IF(IXHR.EQ.0)IXHR=24
      CALL MDYH2(IXDA,IXHR,IM2,ID2,IY2,IH2,DUM1,DUM2,MODTZC)
C
C
      IF (ISETMODS .EQ. 1) THEN
      WRITE(MESSAGESTRING,991)
     >      IM1,ID1,IY1,IH1,MODTZC,IM2,ID2,IY2,IH2,MODTZC
991   FORMAT('MULTIPLE SETQMEAN MODS - START MOD (',I2,
     1  '/',I2,'/',I4,'-',I2,1X,A4,') END MOD (',I2,'/',I2,
     2  '/',I4,'-',I2,1X,A4,')')
      ELSE
      WRITE(MESSAGESTRING,992)
     >      IM1,ID1,IY1,IH1,MODTZC,IM2,ID2,IY2,IH2,MODTZC
992   FORMAT('ONE SETQMEAN MOD - START MOD (',I2,
     1  '/',I2,'/',I4,'-',I2,1X,A4,') END MOD (',I2,'/',I2,
     2  '/',I4,'-',I2,1X,A4,')')
      ENDIF
      call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)
C================

      WRITE(MESSAGESTRING,400) M126ON,MJ126,NVM126
400   FORMAT(11X,'*** LEAVING MSETQM *** - M126ON=',L4,', MJ126=',I11,
     1 ', NVM126=',I5)
      call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)

      IF ( NVM126.GT.0 ) THEN
        WRITE(FORMATSTR, *) '%12.4f'
        call logonedimensionarrayfromfortran(DEBUG_LEVEL,NULLLINE,1,6,
     >        FORMATSTR,1,NVM126,1,VM126)
        IF (ISETMODS .EQ. 1) THEN
         WRITE(MESSAGESTRING,410) 
410      FORMAT('==> Note: The gap between multiple SETQMEAN modifiers s
     >how -888.')
         call logfromfortran(DEBUG_LEVEL, MESSAGESTRING)
        ENDIF
      END IF
C
      RETURN
      END
C====================================================================
C  MODULE MISTDT
C
C  DESC THIS FUNCTION SETS THE JULIAN HOUR ENTERED TO THE
C  DESC NEAREST TIME INTERVAL (ALSO ENTERED)
C
C  THIS FUNCTION IS USED WITHIN THE MODS SUBROUTINES
C  ORIGINALLY WRITTEN BY GEORGE F. SMITH - HRL - AUG 1985
C====================================================================
      INTEGER FUNCTION MISTDT(IDATE,IDT)
      
      JSTHR=IDATE
      ITMPHR=MOD(JSTHR,24)
      IF(ITMPHR.LT.1)GO TO 10
      IHOUR=(ITMPHR/IDT)*IDT
      LEFTOV=ITMPHR-IHOUR
      IF(LEFTOV.EQ.0)GO TO 10
C
C  HOUR ENTERED NOT EXACTLY ON IDT - MOVE TO CLOSEST DT
C
      IADDHR=IHOUR
      IF(LEFTOV.GE.IDT)IADDHR=IHOUR+IDT
      JSTHR=(JSTHR/24)*24 + IADDHR
C
   10 MISTDT=JSTHR
      RETURN
      END
